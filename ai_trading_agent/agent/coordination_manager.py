"""
Coordination Manager Module

This module provides a central coordination point for all strategies in the AI Trading Agent
system. It manages:
1. Signal coordination across strategies
2. Resource allocation based on performance
3. Performance attribution and reporting
4. Cross-strategy correlation analysis

The CoordinationManager handles the combined knowledge from multiple strategies to produce
optimal trading decisions.
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Any, Optional
from datetime import datetime
import logging
import os
import json

from .strategy import BaseStrategy, RichSignal, RichSignalsDict
from ..coordination.strategy_coordinator import StrategyCoordinator
from ..coordination.performance_attribution import PerformanceAttributor
from ..utils.logging import get_logger

# Configure logger
logger = get_logger(__name__)


class CoordinationManager:
    """
    Manages coordination between multiple trading strategies.
    
    The CoordinationManager:
    1. Collects signals from all active strategies
    2. Uses the StrategyCoordinator to resolve conflicts and optimize allocations
    3. Tracks performance for attribution and analysis
    4. Generates performance reports and visualizations
    5. Provides optimized combined signals for execution
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize the CoordinationManager.
        
        Args:
            config: Configuration dictionary with parameters
                - strategies: List of strategy configurations
                - coordination_config: Configuration for strategy coordination
                - attribution_config: Configuration for performance attribution
                - output_path: Directory to save reports and visualizations
                - report_frequency: How often to generate reports (in trading periods)
        """
        self.strategy_names = [s.get("name", f"Strategy_{i}") for i, s in enumerate(config.get("strategies", []))]
        self.output_path = config.get("output_path", "./reports")
        self.report_frequency = config.get("report_frequency", 50)
        
        # Initialize coordination components
        coord_config = config.get("coordination_config", {})
        if not coord_config.get("strategies"):
            coord_config["strategies"] = self.strategy_names
        self.coordinator = StrategyCoordinator(coord_config)
        
        attr_config = config.get("attribution_config", {})
        if not attr_config.get("strategies"):
            attr_config["strategies"] = self.strategy_names
        if not attr_config.get("output_path"):
            attr_config["output_path"] = os.path.join(self.output_path, "attribution")
        self.attributor = PerformanceAttributor(attr_config)
        
        # State tracking
        self.period_counter = 0
        self.active_strategies = set()
        self.strategy_signals = {}
        self.combined_signals = {}
        self.recent_performance = {}
        
        # Ensure output directory exists
        if self.output_path and not os.path.exists(self.output_path):
            os.makedirs(self.output_path)
            
        logger.info(f"CoordinationManager initialized with {len(self.strategy_names)} strategies")
    
    def register_strategy(self, strategy_name: str) -> None:
        """
        Register a strategy with the coordination manager.
        
        Args:
            strategy_name: Name of the strategy to register
        """
        if strategy_name not in self.strategy_names:
            self.strategy_names.append(strategy_name)
            
        self.active_strategies.add(strategy_name)
        logger.info(f"Strategy {strategy_name} registered with coordination manager")
    
    def record_strategy_signals(self, strategy_name: str, signals: RichSignalsDict, 
                              timestamp: Optional[str] = None) -> None:
        """
        Record signals from a strategy for coordination.
        
        Args:
            strategy_name: Name of the strategy
            signals: Dictionary of signals generated by the strategy
            timestamp: Optional timestamp for the signals
        """
        # Register strategy if not already registered
        if strategy_name not in self.active_strategies:
            self.register_strategy(strategy_name)
        
        # Use current timestamp if not provided
        if timestamp is None:
            timestamp = datetime.now().isoformat()
            
        # Store strategy signals
        self.strategy_signals[strategy_name] = signals
        
        logger.info(f"Recorded signals from {strategy_name} for {len(signals)} symbols")
    
    def coordinate_signals(self) -> RichSignalsDict:
        """
        Coordinate signals from all registered strategies to produce optimal combined signals.
        
        Returns:
            Dictionary of coordinated signals
        """
        if not self.strategy_signals:
            logger.warning("No strategy signals available for coordination")
            return {}
            
        # Use strategy coordinator to resolve conflicts and optimize allocations
        coordinated_signals = self.coordinator.coordinate_signals(self.strategy_signals)
        
        # Store the combined signals
        self.combined_signals = coordinated_signals
        
        # Increment period counter
        self.period_counter += 1
        
        # Generate reports if it's time
        if self.period_counter % self.report_frequency == 0:
            self.generate_attribution_report()
        
        logger.info(f"Coordinated signals for {len(coordinated_signals)} symbols")
        return coordinated_signals
    
    def record_performance(self, strategy_name: str, symbol: str, 
                          metrics: Dict[str, float], 
                          timestamp: Optional[str] = None) -> None:
        """
        Record performance metrics for a strategy.
        
        Args:
            strategy_name: Name of the strategy
            symbol: Trading symbol
            metrics: Dictionary of performance metrics
            timestamp: Optional timestamp for the performance record
        """
        # Use current timestamp if not provided
        if timestamp is None:
            timestamp = datetime.now().isoformat()
            
        # Update strategy coordinator
        self.coordinator.update_performance(strategy_name, symbol, timestamp, metrics)
        
        # Record in performance attributor
        self.attributor.record_performance(strategy_name, symbol, timestamp, metrics)
        
        # Store recent performance
        if strategy_name not in self.recent_performance:
            self.recent_performance[strategy_name] = {}
        
        self.recent_performance[strategy_name][symbol] = metrics
        
        logger.info(f"Recorded performance for {strategy_name} on {symbol}")
    
    def record_combined_performance(self, symbol: str, metrics: Dict[str, float],
                                  timestamp: Optional[str] = None) -> None:
        """
        Record performance metrics for the combined strategy.
        
        Args:
            symbol: Trading symbol
            metrics: Dictionary of performance metrics
            timestamp: Optional timestamp for the performance record
        """
        # Use current timestamp if not provided
        if timestamp is None:
            timestamp = datetime.now().isoformat()
            
        # Record in performance attributor
        self.attributor.record_performance("Combined", symbol, timestamp, metrics, is_combined=True)
        
        logger.info(f"Recorded combined performance for {symbol}")
    
    def get_strategy_allocation(self, strategy_name: str) -> float:
        """
        Get the current capital allocation for a strategy.
        
        Args:
            strategy_name: Name of the strategy
            
        Returns:
            Capital allocation as a fraction (0-1)
        """
        if hasattr(self.coordinator, "strategy_allocations"):
            return self.coordinator.strategy_allocations.get(strategy_name, 1.0 / len(self.active_strategies))
        
        # Default to equal allocation
        return 1.0 / len(self.active_strategies)
    
    def get_strategy_correlations(self) -> Dict[Tuple[str, str], float]:
        """
        Get the correlation matrix between strategies.
        
        Returns:
            Dictionary mapping strategy pairs to their correlation
        """
        if hasattr(self.coordinator, "correlation_matrix"):
            return self.coordinator.correlation_matrix
        
        return {}
    
    def generate_attribution_report(self, output_format: str = "json") -> str:
        """
        Generate a performance attribution report.
        
        Args:
            output_format: Report format ('json', 'csv', or 'text')
            
        Returns:
            Path to the generated report
        """
        report_path = self.attributor.generate_attribution_report(output_format)
        
        if report_path:
            logger.info(f"Generated attribution report: {report_path}")
        else:
            logger.warning("Failed to generate attribution report")
            
        return report_path
    
    def visualize_attribution(self, strategy: Optional[str] = None) -> str:
        """
        Generate visualizations of attribution analysis.
        
        Args:
            strategy: Specific strategy to visualize (if None, visualize all)
            
        Returns:
            Path to saved visualization file
        """
        plot_path = self.attributor.visualize_attribution(strategy)
        
        if plot_path:
            logger.info(f"Generated attribution visualization: {plot_path}")
        else:
            logger.warning("Failed to generate attribution visualization")
            
        return plot_path
    
    def get_strategy_recommendations(self) -> Dict[str, List[str]]:
        """
        Get improvement recommendations for each strategy.
        
        Returns:
            Dictionary mapping strategy names to lists of recommendations
        """
        # Trigger attribution analysis if not already done
        if not hasattr(self.attributor, "attribution_results") or not self.attributor.attribution_results:
            self.attributor.analyze_contributions()
            
        recommendations = {}
        
        if hasattr(self.attributor, "attribution_results"):
            for strategy, results in self.attributor.attribution_results.items():
                if "improvement_areas" in results:
                    recommendations[strategy] = results["improvement_areas"]
        
        return recommendations
