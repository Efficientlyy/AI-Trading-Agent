"""
Trading strategy implementations.

This module contains various trading strategy implementations for the backtesting framework.
Each strategy processes market data and generates trading signals.
"""

import numpy as np
from abc import ABC, abstractmethod
from datetime import datetime
from typing import List, Optional, Dict, Any, Tuple
import logging

from .models import Signal, SignalType, CandleData, MarketRegime, TimeFrame

# Set up logging
logger = logging.getLogger("backtester.strategies")


class Strategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    All concrete strategy implementations should inherit from this class
    and implement the process_candle method.
    """
    
    def __init__(self, name: str = None):
        self.name = name or self.__class__.__name__
        self.historical_data: Dict[str, List[float]] = {}  # Symbol -> list of prices
        self.signals: List[Signal] = []  # Historical signals
    
    @abstractmethod
    def process_candle(self, candle: CandleData) -> Optional[Signal]:
        """
        Process a new candle and optionally generate a trading signal.
        
        Args:
            candle: The new candle data to process
            
        Returns:
            Optional[Signal]: A trading signal if generated, None otherwise
        """
        pass
    
    def get_signals(self) -> List[Signal]:
        """Get all historical signals generated by this strategy."""
        return self.signals.copy()


class MovingAverageCrossoverStrategy(Strategy):
    """
    Moving average crossover strategy.
    
    Generates buy signals when fast MA crosses above slow MA,
    and sell signals when fast MA crosses below slow MA.
    
    This strategy can use SMA or EMA indicators with configurable periods.
    """
    
    def __init__(self, fast_ma_period: int = 10, slow_ma_period: int = 30, 
                 fast_ma_type: str = "SMA", slow_ma_type: str = "SMA", 
                 min_confidence: float = 0.6):
        super().__init__("MA_Crossover")
        self.fast_ma_period = fast_ma_period
        self.slow_ma_period = slow_ma_period
        self.fast_ma_type = fast_ma_type
        self.slow_ma_type = slow_ma_type
        self.min_confidence = min_confidence
        self.historical_data: Dict[str, List[float]] = {}
        self.fast_ma_values: Dict[str, List[float]] = {}
        self.slow_ma_values: Dict[str, List[float]] = {}
    
    def calculate_ma(self, data: List[float], period: int, ma_type: str) -> float:
        """Calculate moving average."""
        if len(data) < period:
            return data[-1] if data else 0
        
        if ma_type == "SMA":
            return sum(data[-period:]) / period
        elif ma_type == "EMA":
            # Simple EMA implementation
            alpha = 2 / (period + 1)
            ema = data[-period]
            for price in data[-period+1:]:
                ema = (price * alpha) + (ema * (1 - alpha))
            return ema
        else:
            return sum(data[-period:]) / period
    
    def process_candle(self, candle: CandleData) -> Optional[Signal]:
        """Process a new candle and generate signals."""
        symbol = candle.symbol
        
        # Initialize data structure if needed
        if symbol not in self.historical_data:
            self.historical_data[symbol] = []
            self.fast_ma_values[symbol] = []
            self.slow_ma_values[symbol] = []
        
        # Add new price data
        self.historical_data[symbol].append(candle.close)
        
        # Need enough data for slow MA
        if len(self.historical_data[symbol]) < self.slow_ma_period:
            return None
        
        # Calculate MAs
        fast_ma = self.calculate_ma(self.historical_data[symbol], self.fast_ma_period, self.fast_ma_type)
        slow_ma = self.calculate_ma(self.historical_data[symbol], self.slow_ma_period, self.slow_ma_type)
        
        # Store MA values
        self.fast_ma_values[symbol].append(fast_ma)
        self.slow_ma_values[symbol].append(slow_ma)
        
        # Previous MAs (if available)
        signal = None
        if len(self.fast_ma_values[symbol]) > 1 and len(self.slow_ma_values[symbol]) > 1:
            prev_fast_ma = self.fast_ma_values[symbol][-2]
            prev_slow_ma = self.slow_ma_values[symbol][-2]
            
            # Crossover detection
            if prev_fast_ma <= prev_slow_ma and fast_ma > slow_ma:
                # Calculate confidence based on the strength of crossover
                cross_strength = (fast_ma - slow_ma) / slow_ma
                confidence = min(1.0, cross_strength * 10 + 0.5)
                
                if confidence >= self.min_confidence:
                    signal = Signal(
                        signal_type=SignalType.BUY, 
                        timestamp=candle.timestamp, 
                        symbol=symbol, 
                        confidence=confidence,
                        metadata={
                            'fast_ma': fast_ma,
                            'slow_ma': slow_ma,
                            'cross_strength': cross_strength
                        }
                    )
                    self.signals.append(signal)
                    
            elif prev_fast_ma >= prev_slow_ma and fast_ma < slow_ma:
                # Calculate confidence based on the strength of crossover
                cross_strength = (slow_ma - fast_ma) / slow_ma
                confidence = min(1.0, cross_strength * 10 + 0.5)
                
                if confidence >= self.min_confidence:
                    signal = Signal(
                        signal_type=SignalType.SELL, 
                        timestamp=candle.timestamp, 
                        symbol=symbol, 
                        confidence=confidence,
                        metadata={
                            'fast_ma': fast_ma,
                            'slow_ma': slow_ma,
                            'cross_strength': cross_strength
                        }
                    )
                    self.signals.append(signal)
        
        return signal


class EnhancedMAStrategy(MovingAverageCrossoverStrategy):
    """
    Enhanced moving average crossover strategy with:
    - Market regime detection
    - Volatility-based position sizing
    - Filters for ranging/trending markets
    """
    
    def __init__(self, fast_ma_period: int = 8, slow_ma_period: int = 21, 
                 fast_ma_type: str = "EMA", slow_ma_type: str = "EMA", 
                 min_confidence: float = 0.4, volatility_period: int = 20,
                 trend_strength_period: int = 100, use_regime_filter: bool = True):
        super().__init__(fast_ma_period, slow_ma_period, fast_ma_type, slow_ma_type, min_confidence)
        self.name = "Enhanced_MA"
        self.volatility_period = volatility_period
        self.trend_strength_period = trend_strength_period
        self.use_regime_filter = use_regime_filter
        self.regimes: Dict[str, MarketRegime] = {}
        self.volatility: Dict[str, float] = {}
    
    def detect_market_regime(self, symbol: str) -> MarketRegime:
        """
        Detect the current market regime (trending, ranging, volatile).
        
        Uses price action and indicator behavior to classify the current market.
        """
        if len(self.historical_data.get(symbol, [])) < self.trend_strength_period:
            return MarketRegime(MarketRegime.RANGE, 0.5)
        
        prices = self.historical_data[symbol][-self.trend_strength_period:]
        
        # Calculate directional movement
        direction = 1 if prices[-1] > prices[0] else -1
        price_change_pct = abs(prices[-1] / prices[0] - 1)
        
        # Calculate price volatility
        returns = [prices[i] / prices[i-1] - 1 for i in range(1, len(prices))]
        volatility = np.std(returns) * np.sqrt(252)  # Annualized
        
        # Detect regime type
        if price_change_pct > 0.15:  # Strong trend
            regime_type = MarketRegime.TREND
            strength = min(1.0, price_change_pct / 0.3)  # Scale up to 30% move
        elif volatility > 0.03:  # Highly volatile
            regime_type = MarketRegime.VOLATILE
            strength = min(1.0, volatility / 0.06)  # Scale up to 6% daily volatility
        else:  # Ranging market
            regime_type = MarketRegime.RANGE
            strength = 1.0 - price_change_pct / 0.15  # Lower strength for stronger moves
        
        return MarketRegime(
            type=regime_type,
            strength=strength,
            direction=direction,
            start_time=datetime.now(),
            metadata={
                'price_change_pct': price_change_pct,
                'volatility': volatility
            }
        )
    
    def calculate_volatility(self, symbol: str) -> float:
        """Calculate current market volatility."""
        if len(self.historical_data.get(symbol, [])) < self.volatility_period:
            return 0.02  # Default volatility estimate
        
        prices = self.historical_data[symbol][-self.volatility_period:]
        returns = [prices[i] / prices[i-1] - 1 for i in range(1, len(prices))]
        daily_volatility = np.std(returns) * np.sqrt(252)  # Annualized
        
        return daily_volatility
    
    def process_candle(self, candle: CandleData) -> Optional[Signal]:
        """Process candle with enhanced filters and regime detection."""
        symbol = candle.symbol
        
        # Get basic signal from parent class
        signal = super().process_candle(candle)
        
        # Apply additional filters only if we have a signal
        if signal is not None:
            # Update market regime
            self.regimes[symbol] = self.detect_market_regime(symbol)
            
            # Calculate volatility
            self.volatility[symbol] = self.calculate_volatility(symbol)
            
            # Enhance signal with additional metadata
            signal.metadata.update({
                'market_regime': self.regimes[symbol].type,
                'regime_strength': self.regimes[symbol].strength,
                'volatility': self.volatility[symbol],
                'recommended_size': 1.0 / max(self.volatility[symbol] * 10, 1.0)  # Risk-based position sizing
            })
            
            # Apply regime filter if enabled
            if self.use_regime_filter:
                regime = self.regimes[symbol]
                
                # Only take buy signals in uptrends and sell signals in downtrends
                if (signal.signal_type == SignalType.BUY and regime.type == MarketRegime.TREND and regime.direction < 0) or \
                   (signal.signal_type == SignalType.SELL and regime.type == MarketRegime.TREND and regime.direction > 0):
                    return None  # Skip signal as it's against the primary trend
                
                # Reduce confidence in ranging markets
                if regime.type == MarketRegime.RANGE:
                    signal.confidence *= 0.7
                
                # Skip low confidence signals in volatile markets
                if regime.type == MarketRegime.VOLATILE and signal.confidence < 0.7:
                    return None
        
        return signal


class RSIStrategy(Strategy):
    """
    Relative Strength Index (RSI) strategy.
    
    Generates buy signals when RSI is below oversold_threshold,
    and sell signals when RSI is above overbought_threshold.
    """
    
    def __init__(self, period: int = 14, overbought_threshold: float = 70.0, 
                 oversold_threshold: float = 30.0, min_confidence: float = 0.6):
        super().__init__("RSI")
        self.period = period
        self.overbought_threshold = overbought_threshold
        self.oversold_threshold = oversold_threshold
        self.min_confidence = min_confidence
        self.historical_data: Dict[str, List[float]] = {}
        self.rsi_values: Dict[str, List[float]] = {}
    
    def calculate_rsi(self, prices: List[float]) -> float:
        """Calculate RSI value from price data."""
        if len(prices) < self.period + 1:
            return 50.0  # Default to neutral
        
        # Calculate price changes
        deltas = [prices[i] - prices[i-1] for i in range(1, len(prices))]
        
        # Separate gains and losses
        gains = [delta if delta > 0 else 0 for delta in deltas]
        losses = [abs(delta) if delta < 0 else 0 for delta in deltas]
        
        # Calculate average gain and loss over period
        avg_gain = sum(gains[-self.period:]) / self.period
        avg_loss = sum(losses[-self.period:]) / self.period
        
        # Calculate RSI
        if avg_loss == 0:
            return 100.0
        
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi
    
    def process_candle(self, candle: CandleData) -> Optional[Signal]:
        """Process a new candle and generate signals based on RSI."""
        symbol = candle.symbol
        
        # Initialize data structure if needed
        if symbol not in self.historical_data:
            self.historical_data[symbol] = []
            self.rsi_values[symbol] = []
        
        # Add new price data
        self.historical_data[symbol].append(candle.close)
        
        # Need enough data for RSI
        if len(self.historical_data[symbol]) < self.period + 1:
            return None
        
        # Calculate RSI
        rsi = self.calculate_rsi(self.historical_data[symbol])
        self.rsi_values[symbol].append(rsi)
        
        # Generate signals based on RSI thresholds
        signal = None
        
        # Previous RSI value if available
        prev_rsi = self.rsi_values[symbol][-2] if len(self.rsi_values[symbol]) > 1 else None
        
        # Oversold condition - Buy signal
        if rsi < self.oversold_threshold and (prev_rsi is None or prev_rsi >= self.oversold_threshold):
            # Calculate confidence based on how oversold
            confidence = min(1.0, (self.oversold_threshold - rsi) / 20.0 + 0.5)
            
            if confidence >= self.min_confidence:
                signal = Signal(
                    signal_type=SignalType.BUY,
                    timestamp=candle.timestamp,
                    symbol=symbol,
                    confidence=confidence,
                    metadata={'rsi': rsi}
                )
                self.signals.append(signal)
        
        # Overbought condition - Sell signal
        elif rsi > self.overbought_threshold and (prev_rsi is None or prev_rsi <= self.overbought_threshold):
            # Calculate confidence based on how overbought
            confidence = min(1.0, (rsi - self.overbought_threshold) / 20.0 + 0.5)
            
            if confidence >= self.min_confidence:
                signal = Signal(
                    signal_type=SignalType.SELL,
                    timestamp=candle.timestamp,
                    symbol=symbol,
                    confidence=confidence,
                    metadata={'rsi': rsi}
                )
                self.signals.append(signal)
        
        return signal


class MACDStrategy(Strategy):
    """
    Moving Average Convergence Divergence (MACD) strategy.
    
    Generates buy signals on bullish crossovers and sell signals on bearish crossovers.
    """
    
    def __init__(self, fast_period: int = 12, slow_period: int = 26, 
                 signal_period: int = 9, min_confidence: float = 0.6):
        super().__init__("MACD")
        self.fast_period = fast_period
        self.slow_period = slow_period
        self.signal_period = signal_period
        self.min_confidence = min_confidence
        self.historical_data: Dict[str, List[float]] = {}
        self.macd_line: Dict[str, List[float]] = {}
        self.signal_line: Dict[str, List[float]] = {}
        self.histogram: Dict[str, List[float]] = {}
    
    def calculate_ema(self, data: List[float], period: int) -> float:
        """Calculate Exponential Moving Average."""
        if len(data) < period:
            return sum(data) / len(data) if data else 0
        
        alpha = 2 / (period + 1)
        ema = sum(data[:period]) / period
        
        for price in data[period:]:
            ema = price * alpha + ema * (1 - alpha)
        
        return ema
    
    def calculate_macd(self, prices: List[float]) -> Tuple[float, float, float]:
        """Calculate MACD line, signal line, and histogram."""
        if len(prices) < self.slow_period:
            return 0, 0, 0
        
        # Calculate EMAs
        fast_ema = self.calculate_ema(prices, self.fast_period)
        slow_ema = self.calculate_ema(prices, self.slow_period)
        
        # MACD line = fast EMA - slow EMA
        macd = fast_ema - slow_ema
        
        # Not enough data for signal line
        if len(self.macd_line.get(prices[0], [])) < self.signal_period:
            return macd, macd, 0
        
        # Signal line = EMA of MACD line
        signal = self.calculate_ema(self.macd_line[prices[0]], self.signal_period)
        
        # Histogram = MACD line - signal line
        histogram = macd - signal
        
        return macd, signal, histogram
    
    def process_candle(self, candle: CandleData) -> Optional[Signal]:
        """Process a new candle and generate signals based on MACD."""
        symbol = candle.symbol
        
        # Initialize data structure if needed
        if symbol not in self.historical_data:
            self.historical_data[symbol] = []
            self.macd_line[symbol] = []
            self.signal_line[symbol] = []
            self.histogram[symbol] = []
        
        # Add new price data
        self.historical_data[symbol].append(candle.close)
        
        # Need enough data for slow EMA
        if len(self.historical_data[symbol]) < self.slow_period:
            return None
        
        # Calculate MACD components
        macd, signal, histogram = self.calculate_macd(self.historical_data[symbol])
        
        # Store values
        self.macd_line[symbol].append(macd)
        self.signal_line[symbol].append(signal)
        self.histogram[symbol].append(histogram)
        
        # Generate signals based on MACD crossovers
        trading_signal = None
        
        # Need at least two points for crossover
        if len(self.macd_line[symbol]) < 2 or len(self.signal_line[symbol]) < 2:
            return None
        
        # Current and previous values
        curr_macd = self.macd_line[symbol][-1]
        prev_macd = self.macd_line[symbol][-2]
        curr_signal = self.signal_line[symbol][-1]
        prev_signal = self.signal_line[symbol][-2]
        
        # Bullish crossover (MACD crosses above signal line)
        if prev_macd <= prev_signal and curr_macd > curr_signal:
            # Calculate confidence based on histogram strength
            confidence = min(1.0, abs(histogram) * 10 + 0.5)
            
            if confidence >= self.min_confidence:
                trading_signal = Signal(
                    signal_type=SignalType.BUY,
                    timestamp=candle.timestamp,
                    symbol=symbol,
                    confidence=confidence,
                    metadata={'macd': curr_macd, 'signal': curr_signal, 'histogram': histogram}
                )
                self.signals.append(trading_signal)
        
        # Bearish crossover (MACD crosses below signal line)
        elif prev_macd >= prev_signal and curr_macd < curr_signal:
            # Calculate confidence based on histogram strength
            confidence = min(1.0, abs(histogram) * 10 + 0.5)
            
            if confidence >= self.min_confidence:
                trading_signal = Signal(
                    signal_type=SignalType.SELL,
                    timestamp=candle.timestamp,
                    symbol=symbol,
                    confidence=confidence,
                    metadata={'macd': curr_macd, 'signal': curr_signal, 'histogram': histogram}
                )
                self.signals.append(trading_signal)
        
        return trading_signal


class MultiStrategySystem(Strategy):
    """
    Multi-strategy trading system that combines signals from multiple strategies.
    
    Uses a weighted voting system to generate consensus signals.
    """
    
    def __init__(self, strategies: List[Tuple[Strategy, float]], min_consensus: float = 0.6):
        """
        Initialize the multi-strategy system.
        
        Args:
            strategies: List of (strategy, weight) tuples
            min_consensus: Minimum consensus level required to generate a signal (0.0-1.0)
        """
        super().__init__("MultiStrategy")
        self.strategies = strategies
        self.min_consensus = min_consensus
        self.latest_signals: Dict[str, List[Signal]] = {}
    
    def process_candle(self, candle: CandleData) -> Optional[Signal]:
        """Process candle through all strategies and generate consensus signal."""
        symbol = candle.symbol
        
        # Initialize signal storage if needed
        if symbol not in self.latest_signals:
            self.latest_signals[symbol] = []
        
        # Reset latest signals for this symbol
        self.latest_signals[symbol] = []
        
        # Process candle through each strategy
        for strategy, _ in self.strategies:
            signal = strategy.process_candle(candle)
            if signal:
                self.latest_signals[symbol].append(signal)
        
        # If no signals generated, return None
        if not self.latest_signals[symbol]:
            return None
        
        # Calculate consensus
        return self._calculate_consensus(symbol, candle.timestamp)
    
    def _calculate_consensus(self, symbol: str, timestamp: datetime) -> Optional[Signal]:
        """Calculate consensus signal from multiple strategies."""
        if not self.latest_signals.get(symbol):
            return None
        
        # Count buy and sell votes with weights
        buy_votes = 0.0
        sell_votes = 0.0
        total_weight = 0.0
        
        for signal in self.latest_signals[symbol]:
            # Find the matching strategy and weight
            for strategy, weight in self.strategies:
                if isinstance(signal, Signal) and signal.metadata.get('strategy') == strategy.name:
                    total_weight += weight
                    if signal.signal_type == SignalType.BUY:
                        buy_votes += weight * signal.confidence
                    elif signal.signal_type == SignalType.SELL:
                        sell_votes += weight * signal.confidence
        
        # Normalize by total weight
        if total_weight > 0:
            buy_consensus = buy_votes / total_weight
            sell_consensus = sell_votes / total_weight
            
            # Determine signal type with highest consensus
            if buy_consensus > sell_consensus and buy_consensus >= self.min_consensus:
                signal_type = SignalType.BUY
                consensus = buy_consensus
            elif sell_consensus > buy_consensus and sell_consensus >= self.min_consensus:
                signal_type = SignalType.SELL
                consensus = sell_consensus
            else:
                return None  # No clear consensus
            
            # Create consensus signal
            consensus_signal = Signal(
                signal_type=signal_type,
                timestamp=timestamp,
                symbol=symbol,
                confidence=consensus,
                metadata={
                    'buy_consensus': buy_consensus,
                    'sell_consensus': sell_consensus,
                    'contributing_signals': len(self.latest_signals[symbol]),
                    'strategies': [s.name for s, _ in self.strategies]
                }
            )
            
            self.signals.append(consensus_signal)
            return consensus_signal
        
        return None 