"""
Models for the backtesting framework.

This module contains the core data structures and enums used throughout the backtesting framework.
"""

from enum import Enum
from datetime import datetime
from typing import Optional


class TimeFrame(Enum):
    """Time frames for market data and trading."""
    
    MINUTE_1 = "1m"
    MINUTE_5 = "5m"
    MINUTE_15 = "15m"
    MINUTE_30 = "30m"
    HOUR_1 = "1h"
    HOUR_4 = "4h"
    DAY_1 = "1d"
    
    def __str__(self):
        return self.value


class SignalType(Enum):
    """Types of trading signals."""
    
    BUY = "buy"
    SELL = "sell"
    
    def __str__(self):
        return self.value


class Signal:
    """
    Trading signal generated by a strategy.
    
    Attributes:
        signal_type: Type of signal (buy/sell)
        timestamp: When the signal was generated
        symbol: The trading pair/symbol
        confidence: Signal strength/confidence (0.0-1.0)
        metadata: Optional dictionary for additional signal data
    """
    
    def __init__(self, signal_type: SignalType, timestamp: datetime, symbol: str, 
                 confidence: float = 1.0, metadata: Optional[dict] = None):
        self.signal_type = signal_type
        self.timestamp = timestamp
        self.symbol = symbol
        self.confidence = confidence
        self.metadata = metadata or {}
    
    def __str__(self):
        return f"{self.signal_type} signal for {self.symbol} at {self.timestamp} (confidence: {self.confidence:.2f})"


class CandleData:
    """
    Candlestick market data.
    
    Attributes:
        symbol: Trading pair/symbol
        timestamp: Candle timestamp
        open: Opening price
        high: Highest price during the period
        low: Lowest price during the period
        close: Closing price
        volume: Trading volume
        exchange: Exchange name
        timeframe: Candle timeframe
    """
    
    def __init__(self, symbol: str, timestamp: datetime, open: float, high: float, 
                 low: float, close: float, volume: float, exchange: str = "demo",
                 timeframe: TimeFrame = TimeFrame.HOUR_1):
        self.symbol = symbol
        self.timestamp = timestamp
        self.open = open
        self.high = high
        self.low = low
        self.close = close
        self.volume = volume
        self.exchange = exchange
        self.timeframe = timeframe
    
    def __str__(self):
        return (f"{self.symbol} @ {self.timestamp} | "
                f"O: {self.open:.2f} H: {self.high:.2f} L: {self.low:.2f} C: {self.close:.2f} V: {self.volume:.2f}")


class Position:
    """
    Trading position information.
    
    Attributes:
        symbol: Trading pair/symbol
        entry_price: Position entry price
        entry_time: Position entry timestamp
        size: Position size in base currency
        direction: Long (1) or Short (-1)
        stop_loss: Optional stop loss price
        take_profit: Optional take profit price
        metadata: Additional position data
    """
    
    def __init__(self, symbol: str, entry_price: float, entry_time: datetime, 
                 size: float, direction: int = 1, stop_loss: Optional[float] = None, 
                 take_profit: Optional[float] = None, metadata: Optional[dict] = None):
        self.symbol = symbol
        self.entry_price = entry_price
        self.entry_time = entry_time
        self.size = size
        self.direction = direction  # 1 for long, -1 for short
        self.stop_loss = stop_loss
        self.take_profit = take_profit
        self.metadata = metadata or {}
        self.exit_price = None
        self.exit_time = None
        self.pnl = 0.0
        self.pnl_pct = 0.0
        self.status = "open"
    
    def close(self, exit_price: float, exit_time: datetime):
        """Close the position and calculate P&L."""
        self.exit_price = exit_price
        self.exit_time = exit_time
        self.pnl = (exit_price - self.entry_price) * self.size * self.direction
        self.pnl_pct = (exit_price / self.entry_price - 1) * 100 * self.direction
        self.status = "closed"
    
    def update(self, current_price: float, current_time: datetime) -> bool:
        """
        Update position with current price data and check if stop loss or take profit was hit.
        
        Returns:
            bool: True if position should be closed, False otherwise
        """
        if self.status != "open":
            return False
        
        # Check stop loss
        if self.stop_loss is not None:
            if (self.direction == 1 and current_price <= self.stop_loss) or \
               (self.direction == -1 and current_price >= self.stop_loss):
                self.close(self.stop_loss, current_time)
                return True
        
        # Check take profit
        if self.take_profit is not None:
            if (self.direction == 1 and current_price >= self.take_profit) or \
               (self.direction == -1 and current_price <= self.take_profit):
                self.close(self.take_profit, current_time)
                return True
        
        return False
    
    def __str__(self):
        if self.status == "open":
            return (f"{self.symbol} {'LONG' if self.direction == 1 else 'SHORT'} | "
                    f"Entry: {self.entry_price:.2f} @ {self.entry_time} | "
                    f"Size: {self.size:.4f}")
        else:
            return (f"{self.symbol} {'LONG' if self.direction == 1 else 'SHORT'} | "
                    f"Entry: {self.entry_price:.2f} @ {self.entry_time} | "
                    f"Exit: {self.exit_price:.2f} @ {self.exit_time} | "
                    f"P&L: {self.pnl:.2f} ({self.pnl_pct:.2f}%)")


class MarketRegime:
    """
    Market regime classification.
    
    Attributes:
        type: Regime type (trend, range, volatile)
        strength: Regime strength (0.0-1.0)
        direction: Direction if trending (1 for up, -1 for down, 0 for sideways)
        start_time: When the regime began
        metadata: Additional regime data
    """
    
    TREND = "trend"
    RANGE = "range"
    VOLATILE = "volatile"
    
    def __init__(self, type: str, strength: float, direction: int = 0, 
                 start_time: Optional[datetime] = None, metadata: Optional[dict] = None):
        self.type = type
        self.strength = strength
        self.direction = direction
        self.start_time = start_time or datetime.now()
        self.metadata = metadata or {}
    
    def __str__(self):
        direction_str = ""
        if self.type == self.TREND:
            direction_str = "UP" if self.direction > 0 else "DOWN"
        
        return f"{self.type.upper()} {direction_str} | Strength: {self.strength:.2f} | Since: {self.start_time}" 