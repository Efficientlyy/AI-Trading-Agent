#!/usr/bin/env python
"""
Strategy demo for the AI Trading System.

This script demonstrates how trading strategies work in the system by:
1. Creating a simple moving average crossover strategy
2. Simulating market data (candles and indicators)
3. Showing how the strategy processes this data and generates signals
"""

import sys
import os
import asyncio
import random
import json
from datetime import datetime, timedelta
from pathlib import Path
from enum import Enum
from typing import Dict, List, Optional, Any, Set, Tuple

# Add the project root to the Python path to make imports work
sys.path.insert(0, str(Path(__file__).parent.parent))

# Configure logging
import logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Create a logger for this example
logger = logging.getLogger("strategy_demo")


# Define standalone classes for the demo
class TimeFrame(str, Enum):
    """Time frames for market data."""
    M1 = "1m"
    M5 = "5m"
    M15 = "15m"
    M30 = "30m"
    H1 = "1h"
    H4 = "4h"
    D1 = "1d"


class SignalType(str, Enum):
    """Types of trading signals."""
    ENTRY = "entry"
    EXIT = "exit"
    ADJUST = "adjust"


class Signal:
    """Trading signal generated by a strategy."""
    
    def __init__(
        self,
        id: str,
        strategy_id: str,
        exchange: str,
        symbol: str,
        signal_type: SignalType,
        direction: str,  # "long" or "short"
        timeframe: TimeFrame,
        price: float,
        confidence: float,
        reason: str,
        take_profit: Optional[float] = None,
        stop_loss: Optional[float] = None,
        expiration: Optional[datetime] = None,
        metadata: Optional[Dict] = None
    ):
        """Initialize a signal."""
        self.id = id
        self.strategy_id = strategy_id
        self.exchange = exchange
        self.symbol = symbol
        self.signal_type = signal_type
        self.direction = direction
        self.timeframe = timeframe
        self.price = price
        self.confidence = confidence
        self.reason = reason
        self.take_profit = take_profit
        self.stop_loss = stop_loss
        self.created_at = datetime.now()
        self.expiration = expiration or (self.created_at + timedelta(hours=24))
        self.metadata = metadata or {}
        self.is_active = True
        
    def to_dict(self) -> Dict:
        """Convert the signal to a dictionary."""
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "exchange": self.exchange,
            "symbol": self.symbol,
            "signal_type": self.signal_type,
            "direction": self.direction,
            "timeframe": self.timeframe,
            "price": self.price,
            "confidence": self.confidence,
            "reason": self.reason,
            "take_profit": self.take_profit,
            "stop_loss": self.stop_loss,
            "created_at": self.created_at.isoformat(),
            "expiration": self.expiration.isoformat(),
            "metadata": self.metadata,
            "is_active": self.is_active
        }
    
    def __str__(self) -> str:
        """Format the signal as a string."""
        return (f"{self.signal_type.upper()} {self.direction.upper()} {self.symbol} @ {self.price} "
                f"(confidence: {self.confidence:.2f})")


class CandleData:
    """OHLCV candle data for a symbol."""
    
    def __init__(
        self,
        exchange: str,
        symbol: str,
        timeframe: TimeFrame,
        timestamp: datetime,
        open_price: float,
        high_price: float,
        low_price: float,
        close_price: float,
        volume: float
    ):
        """Initialize candle data."""
        self.exchange = exchange
        self.symbol = symbol
        self.timeframe = timeframe
        self.timestamp = timestamp
        self.open = open_price
        self.high = high_price
        self.low = low_price
        self.close = close_price
        self.volume = volume
    
    def to_dict(self) -> Dict:
        """Convert the candle to a dictionary."""
        return {
            "exchange": self.exchange,
            "symbol": self.symbol,
            "timeframe": self.timeframe,
            "timestamp": self.timestamp.isoformat(),
            "open": self.open,
            "high": self.high,
            "low": self.low,
            "close": self.close,
            "volume": self.volume
        }


class MovingAverageCrossoverStrategy:
    """Simple moving average crossover strategy implementation."""
    
    def __init__(self, strategy_id: str = "ma_crossover"):
        """Initialize the moving average crossover strategy."""
        self.strategy_id = strategy_id
        self.logger = logger
        
        # Strategy-specific configuration
        self.fast_ma_type = "EMA"
        self.fast_ma_period = 12
        self.slow_ma_type = "EMA"
        self.slow_ma_period = 26
        
        # Minimum confidence to generate signals
        self.min_confidence = 0.6
        
        # Position management
        self.use_stop_loss = True
        self.stop_loss_pct = 0.02  # 2%
        self.use_take_profit = True
        self.take_profit_pct = 0.05  # 5%
        
        # Strategy state
        self.latest_ma_values = {}
        self.signal_sent = {}
        self.active_signals = {}
        self.signal_history = []
        
        # Track symbols and exchanges
        self.symbols = ["BTC/USDT", "ETH/USDT", "SOL/USDT"]
        self.exchanges = ["Binance"]
        self.timeframes = [TimeFrame.H1]
        
        self.logger.info(
            "Initialized moving average crossover strategy",
            extra={"fast_ma": f"{self.fast_ma_type}{self.fast_ma_period}",
                  "slow_ma": f"{self.slow_ma_type}{self.slow_ma_period}"}
        )
    
    async def process_candle(self, candle: CandleData) -> None:
        """Process a new candle."""
        symbol = candle.symbol
        exchange = candle.exchange
        timeframe = candle.timeframe
        
        self.logger.info(
            f"Processing candle for {symbol} ({timeframe}): Open={candle.open}, Close={candle.close}"
        )
        
        # In a real system, we would calculate indicators here
        # For this demo, we'll simulate receiving indicator values
        
        # Wait for indicator calculation (simulated)
        await asyncio.sleep(0.1)
        
        # Simulate receiving MA values
        await self.process_indicator(
            symbol, 
            timeframe, 
            f"{self.fast_ma_type}{self.fast_ma_period}", 
            {
                "value": self._simulate_ma_value(candle.close, is_fast=True)
            }
        )
        
        await self.process_indicator(
            symbol, 
            timeframe, 
            f"{self.slow_ma_type}{self.slow_ma_period}", 
            {
                "value": self._simulate_ma_value(candle.close, is_fast=False)
            }
        )
    
    def _simulate_ma_value(self, current_price: float, is_fast: bool) -> float:
        """Simulate a moving average value for demonstration."""
        # Add random noise to create crossovers for the demo
        multiplier = 0.998 if is_fast else 0.997
        noise = random.uniform(-0.005, 0.005)
        return current_price * (multiplier + noise)
    
    async def process_indicator(
        self,
        symbol: str,
        timeframe: TimeFrame,
        indicator_name: str,
        values: Dict
    ) -> None:
        """Process indicator values."""
        if symbol not in self.symbols:
            return
            
        # Store the indicator value
        key = (symbol, timeframe)
        if key not in self.latest_ma_values:
            self.latest_ma_values[key] = {}
        
        current_time = datetime.now()
        if current_time not in self.latest_ma_values[key]:
            self.latest_ma_values[key][current_time] = {}
        
        self.latest_ma_values[key][current_time][indicator_name] = values["value"]
        
        self.logger.info(
            f"Received {indicator_name} = {values['value']:.2f} for {symbol} ({timeframe})"
        )
        
        # Check for crossovers
        await self._analyze_crossovers(symbol, timeframe)
    
    async def _analyze_crossovers(self, symbol: str, timeframe: TimeFrame) -> None:
        """Analyze for potential MA crossovers."""
        key = (symbol, timeframe)
        if key not in self.latest_ma_values:
            return
            
        ma_values = self.latest_ma_values[key]
        if not ma_values or len(ma_values) < 2:
            return
            
        # Get the latest two timestamps
        sorted_times = sorted(ma_values.keys())
        if len(sorted_times) < 2:
            return
            
        current_time = sorted_times[-1]
        previous_time = sorted_times[-2]
        
        current_values = ma_values[current_time]
        previous_values = ma_values[previous_time]
        
        # Check if we have both fast and slow MA values
        fast_ma_name = f"{self.fast_ma_type}{self.fast_ma_period}"
        slow_ma_name = f"{self.slow_ma_type}{self.slow_ma_period}"
        
        if (fast_ma_name not in current_values or 
            slow_ma_name not in current_values or
            fast_ma_name not in previous_values or
            slow_ma_name not in previous_values):
            return
            
        # Get the values
        current_fast = current_values[fast_ma_name]
        current_slow = current_values[slow_ma_name]
        previous_fast = previous_values[fast_ma_name]
        previous_slow = previous_values[slow_ma_name]
        
        # Check for crossovers
        was_above = previous_fast > previous_slow
        is_above = current_fast > current_slow
        
        # Generate signals based on crossovers
        if not was_above and is_above:  # Bullish crossover (fast crosses above slow)
            self.logger.info(
                f"Bullish crossover detected for {symbol} ({timeframe})",
                extra={"fast_ma": current_fast,
                      "slow_ma": current_slow}
            )
            await self._generate_signal(
                symbol, 
                timeframe, 
                "long", 
                current_slow,
                f"{fast_ma_name} crossed above {slow_ma_name}"
            )
        elif was_above and not is_above:  # Bearish crossover (fast crosses below slow)
            self.logger.info(
                f"Bearish crossover detected for {symbol} ({timeframe})",
                extra={"fast_ma": current_fast,
                      "slow_ma": current_slow}
            )
            await self._generate_signal(
                symbol, 
                timeframe, 
                "short", 
                current_slow,
                f"{fast_ma_name} crossed below {slow_ma_name}"
            )
    
    async def _generate_signal(
        self, 
        symbol: str, 
        timeframe: TimeFrame, 
        direction: str,
        price: float,
        reason: str
    ) -> None:
        """Generate a trading signal."""
        # Prevent signal spamming - check if we recently sent a signal for this symbol/timeframe/direction
        key = (symbol, timeframe, direction)
        now = datetime.now()
        
        if key in self.signal_sent:
            last_time = self.signal_sent[key]
            if (now - last_time).total_seconds() < 3600:  # 1 hour cooldown
                self.logger.info(
                    f"Skipping signal generation: cooldown period active for {symbol} {direction}"
                )
                return
        
        # Calculate take profit and stop loss levels
        take_profit = None
        stop_loss = None
        
        if direction == "long":
            if self.use_take_profit:
                take_profit = price * (1 + self.take_profit_pct)
            if self.use_stop_loss:
                stop_loss = price * (1 - self.stop_loss_pct)
        else:  # short
            if self.use_take_profit:
                take_profit = price * (1 - self.take_profit_pct)
            if self.use_stop_loss:
                stop_loss = price * (1 + self.stop_loss_pct)
        
        # Create a signal
        signal = Signal(
            id=f"sig-{len(self.signal_history) + 1}",
            strategy_id=self.strategy_id,
            exchange=self.exchanges[0],
            symbol=symbol,
            signal_type=SignalType.ENTRY,
            direction=direction,
            timeframe=timeframe,
            price=price,
            confidence=random.uniform(0.6, 0.9),  # Random confidence for demo
            reason=reason,
            take_profit=take_profit,
            stop_loss=stop_loss
        )
        
        # Store the signal
        self.active_signals[symbol] = signal
        self.signal_history.append(signal)
        self.signal_sent[key] = now
        
        # Log the signal
        self.logger.info(
            f"Generated signal: {signal}",
            extra={"take_profit": take_profit,
                  "stop_loss": stop_loss}
        )
        print(f"\nðŸ“Š SIGNAL GENERATED: {signal}")
        print(f"  Price: ${price:.2f}")
        print(f"  Reason: {reason}")
        if take_profit:
            print(f"  Take Profit: ${take_profit:.2f}")
        if stop_loss:
            print(f"  Stop Loss: ${stop_loss:.2f}")
        print(f"  Confidence: {signal.confidence:.2f}")
        print()


async def generate_market_data(strategy):
    """Generate simulated market data for the strategy."""
    # Define market parameters
    symbols = ["BTC/USDT", "ETH/USDT", "SOL/USDT"]
    timeframe = TimeFrame.H1
    exchange = "Binance"
    
    # Define price ranges
    price_ranges = {
        "BTC/USDT": (50000, 60000),
        "ETH/USDT": (2500, 3500),
        "SOL/USDT": (80, 120)
    }
    
    # Generate candle data over time
    candle_count = 24  # 24 hours of data
    current_time = datetime.now().replace(minute=0, second=0, microsecond=0)
    
    for symbol in symbols:
        min_price, max_price = price_ranges[symbol]
        price_trend = random.choice(["up", "down", "ranging"])
        
        # Start with a price in the middle of the range
        current_price = (min_price + max_price) / 2
        trend_strength = random.uniform(0.001, 0.003)  # Per candle trend
        
        for i in range(candle_count):
            # Calculate candle time
            candle_time = current_time - timedelta(hours=(candle_count - i))
            
            # Adjust price based on trend
            if price_trend == "up":
                current_price *= (1 + trend_strength + random.uniform(-0.01, 0.02))
            elif price_trend == "down":
                current_price *= (1 - trend_strength + random.uniform(-0.01, 0.01))
            else:  # ranging
                current_price *= (1 + random.uniform(-0.015, 0.015))
            
            # Ensure price stays within range
            current_price = max(min_price, min(max_price, current_price))
            
            # Create random candle around current price
            open_price = current_price * (1 + random.uniform(-0.005, 0.005))
            close_price = current_price * (1 + random.uniform(-0.005, 0.005))
            high_price = max(open_price, close_price) * (1 + random.uniform(0, 0.01))
            low_price = min(open_price, close_price) * (1 - random.uniform(0, 0.01))
            volume = random.uniform(100, 1000)
            
            # Create and process the candle
            candle = CandleData(
                exchange=exchange,
                symbol=symbol,
                timeframe=timeframe,
                timestamp=candle_time,
                open_price=open_price,
                high_price=high_price,
                low_price=low_price,
                close_price=close_price,
                volume=volume
            )
            
            # Process the candle
            logger.info(f"Simulating candle for {symbol} at {candle_time}")
            await strategy.process_candle(candle)
            
            # Wait a bit before the next candle
            await asyncio.sleep(0.5)


async def main():
    """Run the strategy demo."""
    logger.info("Starting strategy demo")
    
    # Create a strategy instance
    strategy = MovingAverageCrossoverStrategy()
    
    # Generate market data for the strategy
    await generate_market_data(strategy)
    
    # Summary of signals generated
    if strategy.signal_history:
        logger.info("Demo completed. Generated signals:")
        for i, signal in enumerate(strategy.signal_history, 1):
            logger.info(f"{i}. {signal}")
    else:
        logger.info("Demo completed. No signals were generated.")


if __name__ == "__main__":
    asyncio.run(main()) 