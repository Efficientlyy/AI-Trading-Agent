#!/usr/bin/env python
"""
Multi-strategy demo for the AI Trading System.

This script demonstrates how multiple trading strategies can work together:
1. Implementing different strategy types (MA crossover, RSI, and MACD)
2. Processing the same market data through each strategy
3. Combining signals using a meta-strategy approach
4. Generating final trading decisions based on consensus
"""

import sys
import os
import asyncio
import random
import json
import math
from datetime import datetime, timedelta
from pathlib import Path
from enum import Enum
from typing import Dict, List, Optional, Any, Set, Tuple

# Add the project root to the Python path to make imports work
sys.path.insert(0, str(Path(__file__).parent.parent))

# Configure logging
import logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Create a logger for this example
logger = logging.getLogger("multi_strategy_demo")


# Define base classes for the demo
class TimeFrame(str, Enum):
    """Time frames for market data."""
    M1 = "1m"
    M5 = "5m"
    M15 = "15m"
    M30 = "30m"
    H1 = "1h"
    H4 = "4h"
    D1 = "1d"


class SignalType(str, Enum):
    """Types of trading signals."""
    ENTRY = "entry"
    EXIT = "exit"
    ADJUST = "adjust"


class Signal:
    """Trading signal generated by a strategy."""
    
    def __init__(
        self,
        id: str,
        strategy_id: str,
        exchange: str,
        symbol: str,
        signal_type: SignalType,
        direction: str,  # "long" or "short"
        timeframe: TimeFrame,
        price: float,
        confidence: float,
        reason: str,
        take_profit: Optional[float] = None,
        stop_loss: Optional[float] = None,
        expiration: Optional[datetime] = None,
        metadata: Optional[Dict] = None
    ):
        """Initialize a signal."""
        self.id = id
        self.strategy_id = strategy_id
        self.exchange = exchange
        self.symbol = symbol
        self.signal_type = signal_type
        self.direction = direction
        self.timeframe = timeframe
        self.price = price
        self.confidence = confidence
        self.reason = reason
        self.take_profit = take_profit
        self.stop_loss = stop_loss
        self.created_at = datetime.now()
        self.expiration = expiration or (self.created_at + timedelta(hours=24))
        self.metadata = metadata or {}
        self.is_active = True
        
    def to_dict(self) -> Dict:
        """Convert the signal to a dictionary."""
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "exchange": self.exchange,
            "symbol": self.symbol,
            "signal_type": self.signal_type,
            "direction": self.direction,
            "timeframe": self.timeframe,
            "price": self.price,
            "confidence": self.confidence,
            "reason": self.reason,
            "take_profit": self.take_profit,
            "stop_loss": self.stop_loss,
            "created_at": self.created_at.isoformat(),
            "expiration": self.expiration.isoformat(),
            "metadata": self.metadata,
            "is_active": self.is_active
        }
    
    def __str__(self) -> str:
        """Format the signal as a string."""
        return (f"{self.signal_type.upper()} {self.direction.upper()} {self.symbol} @ {self.price:.2f} "
                f"(confidence: {self.confidence:.2f}, strategy: {self.strategy_id})")


class CandleData:
    """OHLCV candle data for a symbol."""
    
    def __init__(
        self,
        exchange: str,
        symbol: str,
        timeframe: TimeFrame,
        timestamp: datetime,
        open_price: float,
        high_price: float,
        low_price: float,
        close_price: float,
        volume: float
    ):
        """Initialize candle data."""
        self.exchange = exchange
        self.symbol = symbol
        self.timeframe = timeframe
        self.timestamp = timestamp
        self.open = open_price
        self.high = high_price
        self.low = low_price
        self.close = close_price
        self.volume = volume
    
    def to_dict(self) -> Dict:
        """Convert the candle to a dictionary."""
        return {
            "exchange": self.exchange,
            "symbol": self.symbol,
            "timeframe": self.timeframe,
            "timestamp": self.timestamp.isoformat(),
            "open": self.open,
            "high": self.high,
            "low": self.low,
            "close": self.close,
            "volume": self.volume
        }


class BaseStrategy:
    """Base class for all trading strategies."""
    
    def __init__(self, strategy_id: str):
        """Initialize the strategy."""
        self.strategy_id = strategy_id
        self.logger = logger
        
        # Strategy state
        self.active_signals = {}
        self.signal_history = []
        self.signal_sent = {}
        
        # Track symbols and exchanges
        self.symbols = ["BTC/USDT", "ETH/USDT", "SOL/USDT"]
        self.exchanges = ["Binance"]
        self.timeframes = [TimeFrame.H1]
        
        # Position management
        self.use_stop_loss = True
        self.stop_loss_pct = 0.02  # 2%
        self.use_take_profit = True
        self.take_profit_pct = 0.05  # 5%
        
        # Minimum confidence to generate signals
        self.min_confidence = 0.6
    
    async def process_candle(self, candle: CandleData) -> None:
        """Process a new candle."""
        raise NotImplementedError("Subclasses must implement process_candle")
    
    async def _generate_signal(
        self, 
        symbol: str, 
        timeframe: TimeFrame, 
        direction: str,
        price: float,
        confidence: float,
        reason: str
    ) -> Optional[Signal]:
        """Generate a trading signal."""
        # Prevent signal spamming - check if we recently sent a signal for this symbol/timeframe/direction
        key = (symbol, timeframe, direction)
        now = datetime.now()
        
        if key in self.signal_sent:
            last_time = self.signal_sent[key]
            if (now - last_time).total_seconds() < 3600:  # 1 hour cooldown
                self.logger.info(
                    f"Skipping signal generation: cooldown period active for {symbol} {direction}"
                )
                return None
        
        # Calculate take profit and stop loss levels
        take_profit = None
        stop_loss = None
        
        if direction == "long":
            if self.use_take_profit:
                take_profit = price * (1 + self.take_profit_pct)
            if self.use_stop_loss:
                stop_loss = price * (1 - self.stop_loss_pct)
        else:  # short
            if self.use_take_profit:
                take_profit = price * (1 - self.take_profit_pct)
            if self.use_stop_loss:
                stop_loss = price * (1 + self.stop_loss_pct)
        
        # Create a signal
        signal = Signal(
            id=f"sig-{self.strategy_id}-{len(self.signal_history) + 1}",
            strategy_id=self.strategy_id,
            exchange=self.exchanges[0],
            symbol=symbol,
            signal_type=SignalType.ENTRY,
            direction=direction,
            timeframe=timeframe,
            price=price,
            confidence=confidence,
            reason=reason,
            take_profit=take_profit,
            stop_loss=stop_loss
        )
        
        # Store the signal
        self.active_signals[symbol] = signal
        self.signal_history.append(signal)
        self.signal_sent[key] = now
        
        # Log the signal
        self.logger.info(f"Generated signal: {signal}")
        
        return signal


# Specific strategy implementations
class MovingAverageCrossoverStrategy(BaseStrategy):
    """Strategy that generates signals based on moving average crossovers."""
    
    def __init__(self, strategy_id: str = "ma_crossover"):
        """Initialize the moving average crossover strategy."""
        super().__init__(strategy_id)
        
        # Strategy-specific configuration
        self.fast_ma_type = "EMA"
        self.fast_ma_period = 12
        self.slow_ma_type = "EMA"
        self.slow_ma_period = 26
        
        # Strategy state
        self.latest_ma_values = {}
        
        self.logger.info(
            f"Initialized {self.strategy_id} strategy with {self.fast_ma_type}{self.fast_ma_period} and {self.slow_ma_type}{self.slow_ma_period}"
        )
    
    async def process_candle(self, candle: CandleData) -> None:
        """Process a new candle."""
        symbol = candle.symbol
        exchange = candle.exchange
        timeframe = candle.timeframe
        
        # In a real system, we would calculate indicators here
        # For this demo, we'll simulate receiving indicator values
        await asyncio.sleep(0.1)
        
        # Simulate calculating MA values
        fast_ma = self._simulate_ma_value(candle.close, is_fast=True)
        slow_ma = self._simulate_ma_value(candle.close, is_fast=False)
        
        # Store the values
        key = (symbol, timeframe)
        current_time = candle.timestamp
        
        if key not in self.latest_ma_values:
            self.latest_ma_values[key] = {}
        
        self.latest_ma_values[key][current_time] = {
            f"{self.fast_ma_type}{self.fast_ma_period}": fast_ma,
            f"{self.slow_ma_type}{self.slow_ma_period}": slow_ma
        }
        
        # Check for crossovers
        await self._analyze_crossovers(symbol, timeframe, current_time, candle.close)
    
    def _simulate_ma_value(self, current_price: float, is_fast: bool) -> float:
        """Simulate a moving average value for demonstration."""
        # Add random noise to create crossovers for the demo
        multiplier = 0.998 if is_fast else 0.997
        noise = random.uniform(-0.005, 0.005)
        return current_price * (multiplier + noise)
    
    async def _analyze_crossovers(self, symbol: str, timeframe: TimeFrame, current_time: datetime, current_price: float) -> None:
        """Analyze for potential MA crossovers."""
        key = (symbol, timeframe)
        if key not in self.latest_ma_values:
            return
            
        ma_values = self.latest_ma_values[key]
        if len(ma_values) < 2:
            return
            
        # Get the latest two timestamps
        sorted_times = sorted(ma_values.keys())
        if len(sorted_times) < 2:
            return
            
        current_time = sorted_times[-1]
        previous_time = sorted_times[-2]
        
        current_values = ma_values[current_time]
        previous_values = ma_values[previous_time]
        
        # Check if we have both fast and slow MA values
        fast_ma_name = f"{self.fast_ma_type}{self.fast_ma_period}"
        slow_ma_name = f"{self.slow_ma_type}{self.slow_ma_period}"
        
        if (fast_ma_name not in current_values or 
            slow_ma_name not in current_values or
            fast_ma_name not in previous_values or
            slow_ma_name not in previous_values):
            return
            
        # Get the values
        current_fast = current_values[fast_ma_name]
        current_slow = current_values[slow_ma_name]
        previous_fast = previous_values[fast_ma_name]
        previous_slow = previous_values[slow_ma_name]
        
        # Check for crossovers
        was_above = previous_fast > previous_slow
        is_above = current_fast > current_slow
        
        # Calculate confidence based on the strength of the crossover
        crossover_strength = abs(current_fast - current_slow) / current_slow
        confidence = min(0.9, 0.6 + crossover_strength * 100)
        
        # Generate signals based on crossovers
        if not was_above and is_above:  # Bullish crossover (fast crosses above slow)
            self.logger.info(
                f"[{self.strategy_id}] Bullish crossover detected for {symbol} ({timeframe})"
            )
            await self._generate_signal(
                symbol, 
                timeframe, 
                "long", 
                current_price,
                confidence,
                f"{fast_ma_name} crossed above {slow_ma_name}"
            )
        elif was_above and not is_above:  # Bearish crossover (fast crosses below slow)
            self.logger.info(
                f"[{self.strategy_id}] Bearish crossover detected for {symbol} ({timeframe})"
            )
            await self._generate_signal(
                symbol, 
                timeframe, 
                "short", 
                current_price,
                confidence,
                f"{fast_ma_name} crossed below {slow_ma_name}"
            )


class RSIStrategy(BaseStrategy):
    """Strategy that generates signals based on RSI (Relative Strength Index)."""
    
    def __init__(self, strategy_id: str = "rsi"):
        """Initialize the RSI strategy."""
        super().__init__(strategy_id)
        
        # Strategy-specific configuration
        self.rsi_period = 14
        self.overbought_threshold = 70
        self.oversold_threshold = 30
        
        # Strategy state
        self.latest_rsi_values = {}
        
        self.logger.info(
            f"Initialized {self.strategy_id} strategy with period={self.rsi_period}, "
            f"overbought={self.overbought_threshold}, oversold={self.oversold_threshold}"
        )
    
    async def process_candle(self, candle: CandleData) -> None:
        """Process a new candle."""
        symbol = candle.symbol
        exchange = candle.exchange
        timeframe = candle.timeframe
        
        # In a real system, we would calculate RSI here
        # For this demo, we'll simulate receiving RSI values
        await asyncio.sleep(0.1)
        
        # Simulate calculating RSI value
        rsi_value = self._simulate_rsi_value(candle.close)
        
        # Store the value
        key = (symbol, timeframe)
        current_time = candle.timestamp
        
        if key not in self.latest_rsi_values:
            self.latest_rsi_values[key] = {}
        
        self.latest_rsi_values[key][current_time] = rsi_value
        
        # Check for RSI signals
        await self._analyze_rsi(symbol, timeframe, current_time, candle.close, rsi_value)
    
    def _simulate_rsi_value(self, current_price: float) -> float:
        """Simulate an RSI value for demonstration."""
        # Generate a random RSI value that sometimes crosses the thresholds
        # This will oscillate between 0 and 100
        base_value = 50 + random.uniform(-20, 20)  # Center around 50 with Â±20 variance
        
        # Occasionally generate extreme values
        if random.random() < 0.1:  # 10% chance
            if random.random() < 0.5:  # 50% chance of overbought
                base_value = self.overbought_threshold + random.uniform(1, 10)
            else:  # 50% chance of oversold
                base_value = self.oversold_threshold - random.uniform(1, 10)
        
        return max(0, min(100, base_value))  # Clamp between 0 and 100
    
    async def _analyze_rsi(self, symbol: str, timeframe: TimeFrame, current_time: datetime, current_price: float, rsi_value: float) -> None:
        """Analyze RSI for potential signals."""
        key = (symbol, timeframe)
        if key not in self.latest_rsi_values:
            return
            
        rsi_values = self.latest_rsi_values[key]
        if len(rsi_values) < 2:
            return
            
        # Get the latest two timestamps
        sorted_times = sorted(rsi_values.keys())
        if len(sorted_times) < 2:
            return
            
        current_time = sorted_times[-1]
        previous_time = sorted_times[-2]
        
        current_rsi = rsi_values[current_time]
        previous_rsi = rsi_values[previous_time]
        
        # Calculate confidence based on RSI extremes
        oversold_confidence = max(0.6, 1 - (current_rsi / self.oversold_threshold))
        overbought_confidence = max(0.6, (current_rsi - self.overbought_threshold) / (100 - self.overbought_threshold) + 0.6)
        
        # Generate signals based on RSI
        if previous_rsi >= self.oversold_threshold and current_rsi < self.oversold_threshold:
            # RSI crossed below oversold threshold - bullish signal
            self.logger.info(
                f"[{self.strategy_id}] RSI crossed below oversold ({self.oversold_threshold}) for {symbol}: {current_rsi:.2f}"
            )
            await self._generate_signal(
                symbol, 
                timeframe, 
                "long", 
                current_price,
                oversold_confidence,
                f"RSI oversold: {current_rsi:.2f}"
            )
        elif previous_rsi <= self.overbought_threshold and current_rsi > self.overbought_threshold:
            # RSI crossed above overbought threshold - bearish signal
            self.logger.info(
                f"[{self.strategy_id}] RSI crossed above overbought ({self.overbought_threshold}) for {symbol}: {current_rsi:.2f}"
            )
            await self._generate_signal(
                symbol, 
                timeframe, 
                "short", 
                current_price,
                overbought_confidence,
                f"RSI overbought: {current_rsi:.2f}"
            )


class MACDStrategy(BaseStrategy):
    """Strategy that generates signals based on MACD (Moving Average Convergence Divergence)."""
    
    def __init__(self, strategy_id: str = "macd"):
        """Initialize the MACD strategy."""
        super().__init__(strategy_id)
        
        # Strategy-specific configuration
        self.fast_period = 12
        self.slow_period = 26
        self.signal_period = 9
        
        # Strategy state
        self.latest_macd_values = {}
        
        self.logger.info(
            f"Initialized {self.strategy_id} strategy with fast={self.fast_period}, "
            f"slow={self.slow_period}, signal={self.signal_period}"
        )
    
    async def process_candle(self, candle: CandleData) -> None:
        """Process a new candle."""
        symbol = candle.symbol
        exchange = candle.exchange
        timeframe = candle.timeframe
        
        # In a real system, we would calculate MACD here
        # For this demo, we'll simulate receiving MACD values
        await asyncio.sleep(0.1)
        
        # Simulate calculating MACD values
        macd_line, signal_line, histogram = self._simulate_macd_values(candle.close)
        
        # Store the values
        key = (symbol, timeframe)
        current_time = candle.timestamp
        
        if key not in self.latest_macd_values:
            self.latest_macd_values[key] = {}
        
        self.latest_macd_values[key][current_time] = {
            "macd_line": macd_line,
            "signal_line": signal_line,
            "histogram": histogram
        }
        
        # Check for MACD signals
        await self._analyze_macd(symbol, timeframe, current_time, candle.close)
    
    def _simulate_macd_values(self, current_price: float) -> Tuple[float, float, float]:
        """Simulate MACD values for demonstration."""
        # Generate baseline values proportional to the price
        price_factor = current_price * 0.001  # Scale factor
        
        # Simulate MACD line and signal line with some relative movement
        macd_line = random.uniform(-1.5, 1.5) * price_factor
        signal_line = random.uniform(-1.5, 1.5) * price_factor
        
        # Occasionally create crossovers
        if random.random() < 0.2:  # 20% chance of potential crossover
            if random.random() < 0.5:  # 50% chance of bullish crossover
                macd_line = signal_line + random.uniform(0.1, 0.5) * price_factor
            else:  # 50% chance of bearish crossover
                macd_line = signal_line - random.uniform(0.1, 0.5) * price_factor
        
        # Calculate histogram (difference between MACD and signal line)
        histogram = macd_line - signal_line
        
        return macd_line, signal_line, histogram
    
    async def _analyze_macd(self, symbol: str, timeframe: TimeFrame, current_time: datetime, current_price: float) -> None:
        """Analyze MACD for potential signals."""
        key = (symbol, timeframe)
        if key not in self.latest_macd_values:
            return
            
        macd_values = self.latest_macd_values[key]
        if len(macd_values) < 2:
            return
            
        # Get the latest two timestamps
        sorted_times = sorted(macd_values.keys())
        if len(sorted_times) < 2:
            return
            
        current_time = sorted_times[-1]
        previous_time = sorted_times[-2]
        
        current_macd = macd_values[current_time]
        previous_macd = macd_values[previous_time]
        
        # Check for MACD line and signal line crossovers
        current_macd_above_signal = current_macd["macd_line"] > current_macd["signal_line"]
        previous_macd_above_signal = previous_macd["macd_line"] > previous_macd["signal_line"]
        
        # Calculate confidence based on the strength of the crossover
        crossover_strength = abs(current_macd["macd_line"] - current_macd["signal_line"])
        price_factor = current_price * 0.0001  # Scale factor
        confidence = min(0.9, 0.6 + (crossover_strength / price_factor))
        
        # Generate signals based on MACD crossovers
        if not previous_macd_above_signal and current_macd_above_signal:
            # MACD line crossed above signal line - bullish signal
            self.logger.info(
                f"[{self.strategy_id}] MACD crossed above signal line for {symbol}"
            )
            await self._generate_signal(
                symbol, 
                timeframe, 
                "long", 
                current_price,
                confidence,
                f"MACD bullish crossover"
            )
        elif previous_macd_above_signal and not current_macd_above_signal:
            # MACD line crossed below signal line - bearish signal
            self.logger.info(
                f"[{self.strategy_id}] MACD crossed below signal line for {symbol}"
            )
            await self._generate_signal(
                symbol, 
                timeframe, 
                "short", 
                current_price,
                confidence,
                f"MACD bearish crossover"
            )


class MetaStrategy:
    """A meta-strategy that combines signals from multiple strategies."""
    
    def __init__(self, strategies: List[BaseStrategy]):
        """Initialize the meta-strategy with a list of strategies."""
        self.strategies = strategies
        self.logger = logger
        self.signals_by_symbol = {}
        self.decisions = []
        
        # Weighting for each strategy (0.0 to 1.0)
        self.strategy_weights = {}
        for strategy in strategies:
            # Default weights - in a real system these would be optimized
            if "ma_crossover" in strategy.strategy_id:
                self.strategy_weights[strategy.strategy_id] = 0.6
            elif "rsi" in strategy.strategy_id:
                self.strategy_weights[strategy.strategy_id] = 0.7
            elif "macd" in strategy.strategy_id:
                self.strategy_weights[strategy.strategy_id] = 0.8
            else:
                self.strategy_weights[strategy.strategy_id] = 0.5
                
        self.logger.info(f"Initialized meta-strategy with {len(strategies)} strategies")
        for strategy_id, weight in self.strategy_weights.items():
            self.logger.info(f"  - {strategy_id}: weight={weight}")
    
    def collect_signals(self) -> Dict[str, List[Signal]]:
        """Collect all active signals from all strategies."""
        all_signals = {}
        
        for strategy in self.strategies:
            for symbol, signal in strategy.active_signals.items():
                if symbol not in all_signals:
                    all_signals[symbol] = []
                all_signals[symbol].append(signal)
        
        self.signals_by_symbol = all_signals
        return all_signals
    
    def analyze_signals(self) -> List[Dict]:
        """Analyze signals and generate trading decisions based on consensus."""
        decisions = []
        
        # First collect all signals
        all_signals = self.collect_signals()
        self.logger.info(f"Collected signals for {len(all_signals)} symbols")
        
        # Analyze each symbol's signals
        for symbol, signals in all_signals.items():
            if not signals:
                continue
                
            self.logger.info(f"Analyzing {len(signals)} signals for {symbol}")
            
            # Count long and short signals with weighted confidence
            long_score = 0.0
            short_score = 0.0
            
            for signal in signals:
                strategy_weight = self.strategy_weights.get(signal.strategy_id, 0.5)
                weighted_confidence = signal.confidence * strategy_weight
                
                if signal.direction == "long":
                    long_score += weighted_confidence
                else:  # short
                    short_score += weighted_confidence
            
            # Normalize by number of strategies
            strategy_count = len(self.strategies)
            long_score /= strategy_count
            short_score /= strategy_count
            
            # Determine the final decision
            direction = None
            confidence = 0.0
            
            if long_score > short_score and long_score > 0.4:
                direction = "long"
                confidence = long_score
            elif short_score > long_score and short_score > 0.4:
                direction = "short"
                confidence = short_score
            
            if direction:
                # Combine reasons from all signals in the chosen direction
                reasons = []
                for signal in signals:
                    if signal.direction == direction:
                        reasons.append(f"{signal.strategy_id}: {signal.reason}")
                
                # Get the average price from all signals
                avg_price = sum(signal.price for signal in signals) / len(signals)
                
                # Create decision
                decision = {
                    "symbol": symbol,
                    "direction": direction,
                    "confidence": confidence,
                    "price": avg_price,
                    "reason": " + ".join(reasons),
                    "signals": [signal.to_dict() for signal in signals],
                    "timestamp": datetime.now().isoformat()
                }
                
                self.logger.info(
                    f"Decision for {symbol}: {direction.upper()} with confidence {confidence:.2f}"
                )
                decisions.append(decision)
            else:
                self.logger.info(f"No consensus reached for {symbol}")
        
        self.decisions = decisions
        return decisions


class MarketDataSimulator:
    """Simulates market data for testing strategies."""
    
    def __init__(self, symbols: List[str], timeframes: List[TimeFrame]):
        """Initialize the market data simulator."""
        self.symbols = symbols
        self.timeframes = timeframes
        self.logger = logger
        self.price_data = {}
        
        # Initialize random price data for each symbol
        for symbol in symbols:
            if symbol == "BTC/USDT":
                self.price_data[symbol] = {
                    "price": 35000.0,
                    "volatility": 0.015
                }
            elif symbol == "ETH/USDT":
                self.price_data[symbol] = {
                    "price": 2200.0,
                    "volatility": 0.02
                }
            elif symbol == "SOL/USDT":
                self.price_data[symbol] = {
                    "price": 90.0,
                    "volatility": 0.025
                }
            else:
                self.price_data[symbol] = {
                    "price": 100.0,
                    "volatility": 0.01
                }
        
        self.logger.info(f"Initialized market data simulator for {len(symbols)} symbols")
    
    async def generate_candle(self, symbol: str, timeframe: TimeFrame, timestamp: datetime) -> CandleData:
        """Generate a simulated candle for the given symbol and timeframe."""
        if symbol not in self.price_data:
            raise ValueError(f"Symbol {symbol} not found in price data")
        
        price_info = self.price_data[symbol]
        current_price = price_info["price"]
        volatility = price_info["volatility"]
        
        # Simulate price movement
        price_change = current_price * random.uniform(-volatility, volatility)
        new_price = max(0.01, current_price + price_change)
        
        # Update the stored price
        self.price_data[symbol]["price"] = new_price
        
        # Generate candle data with some realistic variations
        open_price = current_price
        close_price = new_price
        
        # Add some randomness to high and low
        high_price = max(open_price, close_price) * (1 + random.uniform(0, volatility/2))
        low_price = min(open_price, close_price) * (1 - random.uniform(0, volatility/2))
        
        # Simulate volume
        base_volume = current_price * 10  # Higher price, higher volume in USDT
        volume = base_volume * (1 + random.uniform(-0.5, 1.5))  # Random volume fluctuation
        
        # Create the candle
        candle = CandleData(
            exchange="Binance",
            symbol=symbol,
            timeframe=timeframe,
            timestamp=timestamp,
            open_price=open_price,
            high_price=high_price,
            low_price=low_price,
            close_price=close_price,
            volume=volume
        )
        
        return candle
    
    async def update_prices(self, timestamp: datetime) -> Dict[str, Dict[TimeFrame, CandleData]]:
        """Update prices and generate candles for all symbols and timeframes."""
        candles = {}
        
        for symbol in self.symbols:
            candles[symbol] = {}
            for timeframe in self.timeframes:
                candle = await self.generate_candle(symbol, timeframe, timestamp)
                candles[symbol][timeframe] = candle
        
        return candles


async def run_simulation(strategies: List[BaseStrategy], meta_strategy: MetaStrategy, 
                        simulator: MarketDataSimulator, duration_hours: int = 24, 
                        timeframe: TimeFrame = TimeFrame.H1):
    """Run a simulation of market data processing through strategies."""
    logger.info(f"Starting simulation for {duration_hours} hours with {timeframe} candles")
    
    # Set start time to a recent timestamp
    start_time = datetime.now() - timedelta(hours=duration_hours)
    
    # Generate candles for each hour
    for hour in range(duration_hours):
        timestamp = start_time + timedelta(hours=hour)
        logger.info(f"Processing candles for timestamp: {timestamp}")
        
        # Generate candles for all symbols
        candles = await simulator.update_prices(timestamp)
        
        # Process candles through each strategy
        for symbol, timeframe_candles in candles.items():
            for tf, candle in timeframe_candles.items():
                if tf == timeframe:  # Only process candles for the requested timeframe
                    logger.info(f"Processing {symbol} {tf} candle: close={candle.close:.2f}")
                    for strategy in strategies:
                        await strategy.process_candle(candle)
        
        # Every 4 hours, analyze signals and make decisions
        if hour % 4 == 0 or hour == duration_hours - 1:
            # Analyze signals with the meta-strategy
            decisions = meta_strategy.analyze_signals()
            
            # Log decisions
            if decisions:
                logger.info(f"Generated {len(decisions)} trading decisions:")
                for decision in decisions:
                    logger.info(
                        f"  - {decision['symbol']} {decision['direction'].upper()} @ {decision['price']:.2f} "
                        f"(confidence: {decision['confidence']:.2f})"
                    )
            else:
                logger.info("No trading decisions generated in this period")
        
        # Add some delay to simulate real-time processing
        await asyncio.sleep(0.2)
    
    logger.info("Simulation completed")
    return meta_strategy.decisions


async def main():
    """Run the multi-strategy demo."""
    logger.info("Starting multi-strategy demo")
    
    # Define symbols and timeframes
    symbols = ["BTC/USDT", "ETH/USDT", "SOL/USDT"]
    timeframes = [TimeFrame.H1]
    
    # Create strategies
    ma_strategy = MovingAverageCrossoverStrategy("ma_crossover")
    rsi_strategy = RSIStrategy("rsi")
    macd_strategy = MACDStrategy("macd")
    
    strategies = [ma_strategy, rsi_strategy, macd_strategy]
    
    # Create meta-strategy
    meta_strategy = MetaStrategy(strategies)
    
    # Create market data simulator
    simulator = MarketDataSimulator(symbols, timeframes)
    
    # Run the simulation
    simulation_hours = 24
    decisions = await run_simulation(
        strategies=strategies,
        meta_strategy=meta_strategy,
        simulator=simulator,
        duration_hours=simulation_hours,
        timeframe=TimeFrame.H1
    )
    
    # Summarize results
    if decisions:
        logger.info(f"\nSummary of {len(decisions)} trading decisions:")
        
        # Group by symbol and direction
        symbol_results = {}
        for decision in decisions:
            symbol = decision["symbol"]
            direction = decision["direction"]
            
            if symbol not in symbol_results:
                symbol_results[symbol] = {"long": 0, "short": 0}
            
            symbol_results[symbol][direction] += 1
        
        # Print summary
        for symbol, results in symbol_results.items():
            logger.info(f"  {symbol}: {results['long']} LONG signals, {results['short']} SHORT signals")
    else:
        logger.info("No trading decisions were generated during the simulation")
    
    logger.info("Demo completed")

if __name__ == "__main__":
    asyncio.run(main()) 