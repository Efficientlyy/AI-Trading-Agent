"""
Signal model definitions.

This module defines the Signal class and related enums, which are used to
communicate trading signals between strategies and the portfolio manager.
"""

from datetime import datetime
from enum import Enum
from typing import Dict, Any, Optional


class SignalType(Enum):
    """Type of trading signal."""
    
    ENTRY = "entry"  # Signal to enter a position
    EXIT = "exit"  # Signal to exit a position
    UPDATE = "update"  # Signal to update position parameters
    INFO = "info"  # Informational signal, not actionable


class Signal:
    """Trading signal generated by a strategy.
    
    A signal represents a trading recommendation from a strategy,
    such as entering or exiting a position.
    """
    
    def __init__(
        self,
        symbol: str,
        signal_type: SignalType,
        direction: str,  # "long" or "short"
        price: float,
        confidence: float,
        strategy_id: str,
        timestamp: Optional[datetime] = None,
        reason: str = "",
        metadata: Optional[Dict[str, Any]] = None
    ):
        """Initialize a new trading signal.
        
        Args:
            symbol: Trading symbol (e.g., "BTC/USDT")
            signal_type: Type of signal (entry, exit, etc.)
            direction: Trading direction ("long" or "short")
            price: Current price at signal generation
            confidence: Signal confidence (0.0 to 1.0)
            strategy_id: ID of the strategy generating this signal
            timestamp: Time when signal was generated (now if None)
            reason: Human-readable reason for this signal
            metadata: Additional information about the signal
        """
        self.symbol = symbol
        self.signal_type = signal_type
        self.direction = direction
        self.price = price
        self.confidence = confidence
        self.strategy_id = strategy_id
        self.timestamp = timestamp or datetime.now()
        self.reason = reason
        self.metadata = metadata or {}
        
        # Validate signal parameters
        if confidence < 0.0 or confidence > 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {confidence}")
        
        if direction not in ["long", "short"]:
            raise ValueError(f"Direction must be 'long' or 'short', got {direction}")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to a dictionary.
        
        Returns:
            Dictionary representation of this signal
        """
        return {
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "direction": self.direction,
            "price": self.price,
            "confidence": self.confidence,
            "strategy_id": self.strategy_id,
            "timestamp": self.timestamp.isoformat(),
            "reason": self.reason,
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Signal':
        """Create a Signal object from a dictionary.
        
        Args:
            data: Dictionary containing signal data
            
        Returns:
            Signal object
        """
        return cls(
            symbol=data["symbol"],
            signal_type=SignalType(data["signal_type"]),
            direction=data["direction"],
            price=data["price"],
            confidence=data["confidence"],
            strategy_id=data["strategy_id"],
            timestamp=datetime.fromisoformat(data["timestamp"]) if "timestamp" in data else None,
            reason=data.get("reason", ""),
            metadata=data.get("metadata", {})
        )
    
    def __str__(self) -> str:
        """String representation of this signal.
        
        Returns:
            String representation
        """
        return (
            f"Signal({self.signal_type.value}, {self.symbol}, {self.direction}, "
            f"price: {self.price}, confidence: {self.confidence:.2f})"
        ) 