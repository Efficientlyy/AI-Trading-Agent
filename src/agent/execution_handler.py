# src/agent/execution_handler.py
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List, Union
import pandas as pd # <--- Added import
from src.portfolio.common import Order, Fill, OrderStatus
from src.data.data_manager import DataManagerABC
from src.portfolio.portfolio_manager import PortfolioManagerABC # Import PortfolioManagerABC

# Placeholder types - align with portfolio.py and models later
# Order = Dict[str, Any] # e.g., {'symbol': 'AAPL', 'type': 'MARKET', 'quantity': 10, 'side': 'BUY', 'order_id': 'uuid1'}
# Fill = Dict[str, Any] # e.g., {'symbol': 'AAPL', 'price': 150.5, 'quantity': 10, 'side': 'BUY', 'timestamp': ..., 'order_id': 'uuid1'}
# OrderStatus = Dict[str, Any] # e.g., {'status': 'FILLED', 'filled_quantity': 10, 'average_price': 150.5}

class ExecutionHandlerABC(ABC):
    """Abstract base class for execution handlers.

    Responsible for processing orders and simulating their execution against market data,
    accounting for costs like commission and slippage.
    """

    @abstractmethod
    def execute_order(self, order: Order, market_data: Dict[str, pd.Series]) -> Optional[Order]:
        """Attempts to execute a given order based on current market data.

        Args:
            order: The Order object to be executed.
            market_data: Dictionary mapping symbols to their current market data series.
                         Needed to determine execution price, check limits, etc.

        Returns:
            The Order object with its status updated (e.g., FILLED, REJECTED, PARTIALLY_FILLED)
            and execution details (price, commission). Returns None if the order cannot be
            processed at this time (e.g., insufficient data, market closed - though simulation
            might simplify this).
        """
        raise NotImplementedError

class BaseExecutionHandler(ABC):
    """
    Abstract base class for Execution Handlers.

    Responsible for taking order requests from the PortfolioManager
    and executing them against a market (simulated or live).
    Provides mechanisms to track order status and report fills.
    """

    @abstractmethod
    def submit_order(self, order: Order) -> str:
        """
        Submits an order to the market/broker/simulator.

        Args:
            order: The order object generated by the PortfolioManager.

        Returns:
            A unique order identifier assigned by the execution system.
        """
        pass

    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        Attempts to cancel a pending order.

        Args:
            order_id: The unique identifier of the order to cancel.

        Returns:
            True if the cancel request was successfully sent, False otherwise.
            (Note: Successful sending doesn't guarantee cancellation).
        """
        pass

    @abstractmethod
    def get_order_status(self, order_id: str) -> OrderStatus:
        """
        Retrieves the current status of a specific order.

        Args:
            order_id: The unique identifier of the order.

        Returns:
            An object representing the order's current status.
        """
        pass

    @abstractmethod
    def get_pending_fills(self) -> List[Fill]:
        """
        Retrieves any fills that have occurred since the last check.
        (This might be polled by the Orchestrator or handled via events).

        Returns:
            A list of fill events. An empty list if no new fills.
        """
        pass

# --- Concrete Implementation ---

import logging
from collections import deque
from datetime import datetime
import uuid

class SimulatedExecutionHandler(ExecutionHandlerABC, BaseExecutionHandler):
    """
    A basic simulated execution handler for backtesting.

    - Assumes market orders are filled on the next available data point.
    - Requires market data updates to process fills.
    - Simulates simple fills with optional commission and slippage.
    """
    def __init__(self, portfolio_manager: PortfolioManagerABC, config: Optional[Dict[str, Any]] = None):
        """
        Initializes the SimulatedExecutionHandler.

        Args:
            portfolio_manager: The portfolio manager instance to interact with.
            config: Configuration dictionary. Expected keys:
                - 'fill_price_field' (str): Field from market data to use for fill price
                                            (e.g., 'open', 'close'). Default 'close'.
                - 'commission_rate' (float): Commission per trade (as fraction, e.g., 0.001 for 0.1%). Default 0.0.
                - 'slippage_pct' (float): Fixed slippage percentage per trade (as fraction, e.g., 0.0005 for 0.05%). Default 0.0.
        """
        if portfolio_manager is None:
            raise ValueError("SimulatedExecutionHandler requires a PortfolioManager instance.")
        self.portfolio_manager = portfolio_manager # Store the portfolio manager
        self.config = config if config is not None else {}
        self.fill_price_field = self.config.get('fill_price_field', 'close')
        self.commission_rate = self.config.get('commission_rate', 0.0)
        self.slippage_pct = self.config.get('slippage_pct', 0.0) # Added slippage

        self._pending_orders: Dict[str, Order] = {}
        self._fills_queue: deque[Fill] = deque()
        self._order_statuses: Dict[str, OrderStatus] = {}
        self._next_market_data: Optional[Dict[str, pd.Series]] = None # Store next bar data
        logging.info("SimulatedExecutionHandler initialized.")

    def update_market_data(self, market_data: Dict[str, pd.Series]):
        """
        Receives the next market data update, used for simulating fills.

        Args:
            market_data: Dictionary mapping symbol to the *next* available data bar (Pandas Series).
        """
        logging.debug(f"Market data updated for execution handler.")
        self._next_market_data = market_data
        # Process pending orders with the new data
        self._process_pending_orders()

    def _process_pending_orders(self):
        """ Attempts to fill pending orders based on the latest market data. """
        if not self._next_market_data:
            logging.debug("No market data available to process pending orders.")
            return

        orders_to_remove = []
        for order_id, order in self._pending_orders.items():
            symbol = order['symbol']
            if symbol in self._next_market_data:
                market_data_bar = self._next_market_data[symbol]
                if self.fill_price_field in market_data_bar and not pd.isna(market_data_bar[self.fill_price_field]):
                    base_price = market_data_bar[self.fill_price_field]

                    # Apply Slippage
                    fill_price = base_price
                    if self.slippage_pct > 0:
                        if order['side'].upper() == 'BUY':
                            fill_price = base_price * (1 + self.slippage_pct)
                        elif order['side'].upper() == 'SELL':
                            fill_price = base_price * (1 - self.slippage_pct)
                        logging.debug(f"Applied {self.slippage_pct*100:.4f}% slippage to {symbol} {order['side']}. Base: {base_price:.4f}, Fill: {fill_price:.4f}")

                    # Simple fill logic: fill the entire order quantity
                    quantity = order['quantity']
                    commission = self.commission_rate * quantity * fill_price # Basic commission
                    fill_timestamp = market_data_bar.name # Assuming index is datetime
                    if not isinstance(fill_timestamp, datetime):
                         # Fallback if index isn't datetime (should be handled in DataManager ideally)
                         fill_timestamp = datetime.now()

                    fill_event: Fill = {
                        'symbol': symbol,
                        'price': fill_price,
                        'quantity': quantity,
                        'side': order['side'],
                        'commission': commission,
                        'timestamp': fill_timestamp,
                        'order_id': order_id,
                        'fill_id': f"fill_{order_id}_{uuid.uuid4().hex[:8]}"
                    }
                    self._fills_queue.append(fill_event)
                    self._order_statuses[order_id] = {
                        'status': 'FILLED',
                        'filled_quantity': quantity,
                        'average_price': fill_price,
                        'commission': commission
                    }
                    orders_to_remove.append(order_id)
                    logging.info(f"Simulated Fill: {order['side']} {quantity} {symbol} @ {fill_price:.2f} (Order: {order_id})")
                else:
                    logging.warning(f"Could not find valid fill price ('{self.fill_price_field}') for {symbol} in market data bar.")
            else:
                logging.warning(f"No market data provided for {symbol} to fill order {order_id}.")

        # Remove filled orders from pending list
        for order_id in orders_to_remove:
            del self._pending_orders[order_id]

        # Clear market data after processing to avoid re-using old data
        self._next_market_data = None

    def submit_order(self, order: Order) -> str:
        """
        Submits an order to the simulated market.
        For now, assumes market orders are added directly to pending.

        Args:
            order: The order object.

        Returns:
            The assigned order identifier.
        """
        if 'order_id' not in order or not order['order_id']:
             order['order_id'] = f"sim_ord_{uuid.uuid4().hex[:8]}"
        order_id = order['order_id']

        # Basic validation
        if not all(k in order for k in ['symbol', 'type', 'quantity', 'side']):
            logging.error(f"Invalid order submitted: Missing required fields. Order: {order}")
            raise ValueError("Invalid order structure submitted")

        # Simple handling: Add market orders to pending queue
        if order['type'].upper() == 'MARKET':
            self._pending_orders[order_id] = order
            self._order_statuses[order_id] = {'status': 'PENDING', 'filled_quantity': 0}
            logging.info(f"Order submitted and pending: {order['side']} {order['quantity']} {order['symbol']} (ID: {order_id})")
        else:
             logging.warning(f"Order type '{order['type']}' not yet fully supported by SimulatedExecutionHandler. Treating as PENDING.")
             self._pending_orders[order_id] = order # Add anyway, but won't fill correctly yet
             self._order_statuses[order_id] = {'status': 'PENDING', 'filled_quantity': 0}

        # Immediately try processing if market data happens to be available (unlikely in typical flow)
        # self._process_pending_orders()
        return order_id

    def cancel_order(self, order_id: str) -> bool:
        """
        Attempts to cancel a pending order.

        Returns:
            True if the order was pending and cancelled, False otherwise.
        """
        if order_id in self._pending_orders:
            del self._pending_orders[order_id]
            self._order_statuses[order_id] = {'status': 'CANCELLED'}
            logging.info(f"Order cancelled: {order_id}")
            return True
        else:
            status = self._order_statuses.get(order_id, {}).get('status', 'UNKNOWN')
            logging.warning(f"Attempted to cancel order {order_id}, but it was not pending (Status: {status}).")
            return False

    def get_order_status(self, order_id: str) -> OrderStatus:
        """
        Retrieves the status of a specific order.
        """
        return self._order_statuses.get(order_id, {'status': 'UNKNOWN'})

    def get_pending_fills(self) -> List[Fill]:
        """
        Retrieves and clears the queue of generated fill events.
        """
        fills = list(self._fills_queue)
        self._fills_queue.clear()
        if fills:
             logging.debug(f"Retrieved {len(fills)} pending fills.")
        return fills

    def execute_order(self, order: Order, market_data: Dict[str, pd.Series]) -> Optional[Order]:
        """
        Simulates the execution of an order.

        Args:
            order: The order to simulate.
            market_data: Current market data for price determination.

        Returns:
            The order with updated status and execution details, or None if execution failed pre-fill.
        """
        if order.status != OrderStatus.PENDING:
            logging.warning(f"Attempted to execute non-pending order: {order.order_id}")
            return order # Return as is, maybe already processed or cancelled

        symbol = order.symbol
        if symbol not in market_data:
            logging.error(f"No market data available for {symbol} to execute order {order.order_id}. Rejecting.")
            order.status = OrderStatus.REJECTED
            order.executed_timestamp = market_data[list(market_data.keys())[0]].name # Use timestamp from any available data
            return order

        symbol_data = market_data[symbol]
        current_timestamp = symbol_data.name # Get timestamp from the series index

        # --- Determine Execution Price (Simplified: uses current 'open' or 'close') ---
        # More realistic simulation might use VWAP, check volume, or use tick data.
        execution_price = None
        if order.order_type == OrderType.MARKET:
            # Use 'open' price of the current bar for market orders, assuming execution at bar start
            execution_price = symbol_data.get('open')
            if pd.isna(execution_price):
                 # Fallback to 'close' if 'open' is unavailable
                 execution_price = symbol_data.get('close')

        elif order.order_type == OrderType.LIMIT:
            limit_price = order.limit_price
            if limit_price is None:
                logging.error(f"Limit order {order.order_id} for {symbol} has no limit price. Rejecting.")
                order.status = OrderStatus.REJECTED
                order.executed_timestamp = current_timestamp
                return order

            # Check if limit price is met (using high/low of the current bar for simplicity)
            bar_high = symbol_data.get('high', -np.inf)
            bar_low = symbol_data.get('low', np.inf)

            if order.quantity > 0: # Buy Limit
                if bar_low <= limit_price:
                    # Limit met or exceeded, execute at limit price (simplification)
                    execution_price = limit_price
            elif order.quantity < 0: # Sell Limit
                if bar_high >= limit_price:
                    # Limit met or exceeded, execute at limit price (simplification)
                    execution_price = limit_price

            # If limit not met in this bar, order remains pending
            if execution_price is None:
                logger.debug(f"Limit order {order.order_id} ({symbol} @ {limit_price}) not filled in current bar.")
                return order # Keep it pending

        # Add logic for STOP orders here if needed

        if execution_price is None or pd.isna(execution_price):
            logger.warning(f"Could not determine execution price for order {order.order_id} ({symbol}). Order remains pending.")
            # Or reject if price is fundamentally missing?
            # order.status = OrderStatus.REJECTED
            # order.executed_timestamp = current_timestamp
            return order # Keep pending for now

        # --- Apply Slippage --- #
        if self.slippage_pct > 0:
            slippage = execution_price * self.slippage_pct

            # Apply slippage unfavorably
            if order.quantity > 0: # Buying
                execution_price += slippage
            elif order.quantity < 0: # Selling
                execution_price -= slippage

        # --- Basic Fill Logic (Assumes full fill for simplicity) --- #
        # TODO: Add partial fill logic based on available volume or other constraints
        order.status = OrderStatus.FILLED
        order.executed_price = execution_price
        order.executed_quantity = order.quantity # Assume full fill
        order.executed_timestamp = current_timestamp
        order.commission = self.commission_rate * order.quantity * execution_price

        # --- Notify Portfolio Manager --- #
        try:
            # self.portfolio_manager.update_fill(order)
            logger.info(f"Order Executed & Filled: {order.order_id} - {order.quantity} {symbol} @ {order.executed_price:.4f} (Commission: {order.commission:.2f})")
        except Exception as e:
            logger.error(f"Error updating portfolio after fill for order {order.order_id}: {e}", exc_info=True)
            # What to do here? Revert order status? Log critical error?
            # For simulation, maybe log and continue, but flag the issue.
            order.status = OrderStatus.ERROR # Mark as error state

        return order
